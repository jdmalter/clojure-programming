cmdhistory=["foo" "foo()" "(foo)" "(foo \\"Something\\")" "(foo \\"Here is an arg\\")" "\#'user/foo" "(ns clojure-programming.core)\\r\\n\\r\\n(defn foo\\r\\n  \\"I don't do a whole lot.\\"\\r\\n  [x]\\r\\n  (println x \\"Hello, World\!\\"))" "(foo \\"test\\")" "(ns clojure-programming.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [clojure-programming.core \:refer \:all]))\\r\\n\\r\\n(deftest a-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= 0 1))))" "(a-test)" "(ns chapter_one)\\r\\n\\r\\n(defn foo\\r\\n  \\"I don't do a whole lot.\\"\\r\\n  [x]\\r\\n  (println x \\"Hello, World\!\\"))" "(foo \\"\\")" "(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + number) (count numbers))" "(ns chapter_one.core)\\r\\n\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + number) (count numbers))" "(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + number) (count numbers)))" "(ns chapter_one.core)\\r\\n\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + number) (count numbers)))" "(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))" "(ns chapter_one.core)\\r\\n\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n(average [60 80 100 400])" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n(deftest average\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))" "(average-test)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 161))))" "(average-test)" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n(read-string \\"42\\")\\r\\n\\r\\n(read-string \\"(+ 1 2)\\")" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") \\"42\\"))))" "(read-string-test)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))" "(read-string-test\\n  )" "(read-string-test)" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])" "(pr-str [1 2 3])" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))" "()(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))" "(pr-str-test)" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"" "\\"multiline stings\\r\\nare easy to declare\\"" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare a character literal\\r\\n(class \\\\c)" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c)\\r\\n\\\\u00ff\\r\\n\\\\o41" "(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})" "(\:city person)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))" "(keyword-test)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:user/location) \\"35.779385, -78.675592\\"))))" "(namespace-test)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:user/location calzones) \\"35.779385, -78.675592\\"))))" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday" "(namespace-test)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:user/location calzones) \\"35.779385, -78.675592\\"))))" "(namespace-test)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:/location calzones) \\"35.779385, -78.675592\\"))))" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core-test/location calzones) \\"35.779385, -78.675592\\"))))" "(namespace-test\\n  )" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one/location calzones) \\"35.779385, -78.675592\\"))))" "(namespace-test)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))" "(namespace-test)" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))\\r\\n\\r\\n; Check that regex has been declared\\r\\n(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\"([\\"1-3\\" \\"1\\" \\"3\\"])\\"))))" "(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\"([\\"1-3\\" \\"1\\" \\"3\\"])\\"))))" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))\\r\\n\\r\\n; Check that regex has been declared\\r\\n(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\"([\\"1-3\\" \\"1\\" \\"3\\"])\\"))))" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))\\r\\n\\r\\n; Check that regex has been declared\\r\\n(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\"([1-3 1 3])\\"))))" "(regex-test)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))\\r\\n\\r\\n; Check that regex has been declared\\r\\n(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\"([\\\\\\"1-3\\\\\\" \\\\\\"1\\\\\\" \\\\\\"3\\\\\\"])\\"))))" "(regex-test)" "(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\"([\\"1-3\\" \\"1\\" \\"3\\"])\\"))))" "(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\"([\\\\\\"1-3\\\\\\" \\\\\\"1\\\\\\" \\\\\\"3\\\\\\"])\\"))))" "(regex-test)" "(re-seq regex \\"1-3\\")" "(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\"([\\"1-3\\" \\"1\\" \\"3\\"])\\"))))" "(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\"([\\"\\"1-3\\"\\" \\"\\"1\\"\\" \\"\\"3\\"\\"])\\"))))" "(regex-test)" "(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\"([\\"\\\\1\\\\-\\\\3\\" \\"\\\\1\\" \\"\\\\3\\"])\\"))))" "(regex-test)" "(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") ([\\"1-3\\" \\"1\\" \\"3\\"])))))" "(regex-test)" "(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\\\\\"([\\"1-3\\" \\"1\\" \\"3\\"])\\\\\\"))))" "(regex-test)" "([\\"1-3\\" \\"1\\" \\"3\\"])" "([1-3 1 3])" "\\n\\"([\\"1-3\\" \\"1\\" \\"3\\"])\\"" "\\"([\\\\\\"1-3\\\\\\" \\\\\\"1\\\\\\" \\\\\\"3\\\\\\"])\\"" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))\\r\\n\\r\\n; Check that regex has been declared\\r\\n(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\"([\\\\\\"1-3\\\\\\" \\\\\\"1\\\\\\" \\\\\\"3\\\\\\"])\\"))))" "(regex-test)" " (is (\= (re-seq regex \\"1-3\\") \\"([\\\\\\"1-3\\\\\\" \\\\\\"1\\\\\\" \\\\\\"3\\\\\\"])\\"))" " \\n (\= (re-seq regex \\"1-3\\") \\"([\\\\\\"1-3\\\\\\" \\\\\\"1\\\\\\" \\\\\\"3\\\\\\"])\\")" "(re-seq regex \\"1-3\\")" "\\"([\\\\\\"1-3\\\\\\" \\\\\\"1\\\\\\" \\\\\\"3\\\\\\"])\\"" "([\\\\\\"1-3\\\\\\" \\\\\\"1\\\\\\" \\\\\\"3\\\\\\"])" "([\\"1-3\\" \\"1\\" \\"3\\"])" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)\\r\\n(re-seq regex \\"1-3\\")" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)\\r\\n(re-seq regex \\"1-3\\")\\r\\n\\r\\n; Use the reader macro\\r\\n(read-string \\"(+ 1 2 \#_(* 2 2) 8)\\")" "; Use comment\\r\\n(comment (println \\"hello\\"))" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)\\r\\n(re-seq regex \\"1-3\\")\\r\\n\\r\\n\\r\\n; Use the reader macro\\r\\n(read-string \\"(+ 1 2 \#_(* 2 2) 8)\\")\\r\\n\\r\\n; Use comment\\r\\n(comment (println \\"hello\\"))\\r\\n\\r\\n; Demonstrate the commas evaluate to whitespace\\r\\n(\= [1 2 3] [1, 2, 3])" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))\\r\\n\\r\\n; Check that comma evalues to whitespace\\r\\n(deftest comma-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= ([1 2 3] [,,1,,, 2,, 3,,,,,,]))))" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))\\r\\n\\r\\n; Check that comma evalues to whitespace\\r\\n(deftest comma-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= ([1 2 3] [1, 2, 3])))))" "(comma-test)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))\\r\\n\\r\\n; Check that comma evalues to whitespace\\r\\n(deftest comma-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= [1 2 3] [1, 2, 3]))))" "(comma-test)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))\\r\\n\\r\\n; Check that comma evalues to whitespace\\r\\n(deftest comma-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= [1 2 3] [,,,1, 2,,, ,,,, 3,,,,,,,,,,,,,,]))))" "(comma-test)" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)\\r\\n(re-seq regex \\"1-3\\")\\r\\n\\r\\n\\r\\n; Use the reader macro\\r\\n(read-string \\"(+ 1 2 \#_(* 2 2) 8)\\")\\r\\n\\r\\n; Use comment\\r\\n(comment (println \\"hello\\"))\\r\\n\\r\\n; Demonstrate the commas evaluate to whitespace\\r\\n(\= [1 2 3] [1, 2, 3])\\r\\n\\r\\n; Show off literal data structure\\r\\n'(a b \:name 12.5) ;; list\\r\\n['a 'b \:name 12.5] ;; vector\\r\\n{\:name \\"Chas\\" \:age 31} ;; map\\r\\n\#{1 2 3} ;; set" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)\\r\\n(re-seq regex \\"1-3\\")\\r\\n\\r\\n\\r\\n; Use the reader macro\\r\\n(read-string \\"(+ 1 2 \#_(* 2 2) 8)\\")\\r\\n\\r\\n; Use comment\\r\\n(comment (println \\"hello\\"))\\r\\n\\r\\n; Demonstrate the commas evaluate to whitespace\\r\\n(\= [1 2 3] [1, 2, 3])\\r\\n\\r\\n; Show off literal data structure\\r\\n'(a b \:name 12.5) ;; list\\r\\n['a 'b \:name 12.5] ;; vector\\r\\n{\:name \\"Jacob\\" \:age 20} ;; map\\r\\n\#{1 2 3} ;; set\\r\\n\\r\\n; define a variable\\r\\n(def x 1)" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)\\r\\n(re-seq regex \\"1-3\\")\\r\\n\\r\\n\\r\\n; Use the reader macro\\r\\n(read-string \\"(+ 1 2 \#_(* 2 2) 8)\\")\\r\\n\\r\\n; Use comment\\r\\n(comment (println \\"hello\\"))\\r\\n\\r\\n; Demonstrate the commas evaluate to whitespace\\r\\n(\= [1 2 3] [1, 2, 3])\\r\\n\\r\\n; Show off literal data structure\\r\\n'(a b \:name 12.5) ;; list\\r\\n['a 'b \:name 12.5] ;; vector\\r\\n{\:name \\"Jacob\\" \:age 20} ;; map\\r\\n\#{1 2 3} ;; set\\r\\n\\r\\n; define a variable\\r\\n(def x 1)\\r\\nx" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)\\r\\n(re-seq regex \\"1-3\\")\\r\\n\\r\\n\\r\\n; Use the reader macro\\r\\n(read-string \\"(+ 1 2 \#_(* 2 2) 8)\\")\\r\\n\\r\\n; Use comment\\r\\n(comment (println \\"hello\\"))\\r\\n\\r\\n; Demonstrate the commas evaluate to whitespace\\r\\n(\= [1 2 3] [1, 2, 3])\\r\\n\\r\\n; Show off literal data structure\\r\\n'(a b \:name 12.5) ;; list\\r\\n['a 'b \:name 12.5] ;; vector\\r\\n{\:name \\"Jacob\\" \:age 20} ;; map\\r\\n\#{1 2 3} ;; set\\r\\n\\r\\n; define a variable\\r\\n(def x 1)\\r\\nx ;\= 1\\r\\n\\r\\n; Demonstrate what eval does\\r\\n(eval \:foo) ;\= \:foo\\r\\n(eval [1 2 3]) ;\= [1 2 3]\\r\\n(eval \\"text\\") ;\= \\"text\\"" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (do-something-with-a-number a)\\r\\n  (\= a 5))" "(let [a 5]\\r\\n  (do-something-with-a-number a)\\r\\n  (\= a 5))" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n(def five (StatefulInteger. 5))\\r\\n;\= \#'user/five\\r\\n(def six (StatefulInteger. 6))\\r\\n;\= \#'user/six\\r\\n(.intValue five)\\r\\n;\= 5\\r\\n(\= five six)\\r\\n;\= false\\r\\n(.setInt five 6)\\r\\n;\= nil\\r\\n(\= five six)" "(def five (StatefulInteger. 5))\\r\\n;\= \#'user/five\\r\\n(def six (StatefulInteger. 6))" "(StatefulInteger. 5)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n(import chapter_two.StatefulInteger)\\r\\n\\r\\n(def five (StatefulInteger. 5))\\r\\n;\= \#'user/five\\r\\n(def six (StatefulInteger. 6))\\r\\n;\= \#'user/six\\r\\n(.intValue five)\\r\\n;\= 5\\r\\n(\= five six)\\r\\n;\= false\\r\\n(.setInt five 6)\\r\\n;\= nil\\r\\n(\= five six)" "(StatefulInteger. 5\\n                  )" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; run example code\\r\\n(import chapter_two.StatefulInteger)\\r\\n(def five (new StatefulInteger 5))\\r\\n(def six (new StatefulInteger 6))\\r\\n(.intValue five)\\r\\n(\= five six)\\r\\n(.setState five 6)\\r\\n(\= five six)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; run example code\\r\\n(import chapter_two.StatefulInteger)\\r\\n(def five (new StatefulInteger 5))\\r\\n(def six (new StatefulInteger 6))\\r\\n(. intValue five)\\r\\n(\= five six)\\r\\n(. setState five 6)\\r\\n(\= five six)" "(. five intValue)\\r\\n(\= five six)\\r\\n(. five setState 6)\\r\\n(\= five six)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; run example code\\r\\n(import chapter_two.StatefulInteger)\\r\\n(def five (new StatefulInteger 5))\\r\\n(def six (new StatefulInteger 6))\\r\\n(. five intValue)\\r\\n(\= five six)\\r\\n(. five setState 6)\\r\\n(\= five six)" "(. five intValue)\\r\\n(\= five six)\\r\\n(. five setState 6)\\r\\n(\= five six)" "(. five intValue)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; run example code\\r\\n(import chapter_two.StatefulInteger)\\r\\n(def five (new StatefulInteger 5))\\r\\n(def six (new StatefulInteger 6))\\r\\n(. intValue filve)\\r\\n(\= five six)\\r\\n(. setState five 6)\\r\\n(\= five six)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; run example code\\r\\n(import chapter_two.StatefulInteger)\\r\\n(def five (new StatefulInteger 5))\\r\\n(def six (new StatefulInteger 6))\\r\\n(. intValue five)\\r\\n(\= five six)\\r\\n(. setState five 6)\\r\\n(\= five six)" "(. intValue five)" "(import chapter_two.StatefulInteger)\\r\\n(def five (new StatefulInteger 5))\\r\\n(def six (new StatefulInteger 6))\\r\\n(. intValue five)" "(. intValue five)" "(.intValue five)" "(import chapter_two.StatefulInteger)\\r\\n(def five (new StatefulInteger 5))\\r\\n(def six (new StatefulInteger 6))\\r\\n(.intValue five)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; run example code\\r\\n(import chapter_two.StatefulInteger)\\r\\n(def five (StatefulInteger. 5))\\r\\n(def six (StatefulInteger. 6))\\r\\n(.intValue five)\\r\\n(\= five six)\\r\\n(.setState five 6)\\r\\n(\= five six)" "(.intValue five)" "(def five (StatefulInteger. 5))\\r\\n(def six (StatefulInteger. 6))\\r\\n(.intValue five)" "(import chapter_two.StatefulInteger)\\r\\n(def five (StatefulInteger. 5))\\r\\n(def six (StatefulInteger. 6))\\r\\n(.intValue five)" "(import chapter_two.StatefulInteger)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; run example code\\r\\n(def five (StatefulInteger. 5))\\r\\n(def six (StatefulInteger. 6))\\r\\n(.intValue five)\\r\\n(\= five six)\\r\\n(.setState five 6)\\r\\n(\= five six)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)" "(call-twice println 123)" "(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\"\\r\\n \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4] [5 6 7 8])" "(map * [1 2 3 4] [5 6 7 8 9])" "(map * [1 2 3 4 5] [5 6 7 8 9])" "(map * [1 2 3 4 5 6] [5 6 7 8 9])" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\"\\r\\n \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])" "(reduce max [0 -3 10 48])" "(reduce + 50 [1 2 3 4])" "(reduce\\r\\n (fn [m v]\\r\\n   (assoc m v (* v v)))  \\r\\n {}\\r\\n [1 2 3 4])" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])" "(apply hash-map [\:a 5 \:b 6])" "(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])" "(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])" "(\#(filter % [\\"a\\" 5 \\"b\\" 6]) string?)" "(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)" "(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])\\r\\n(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])\\r\\n\\r\\n; Define a function literal which forces all arguments to be specified\\r\\n(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])\\r\\n(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)\\r\\n\\r\\n; Use function composition\\r\\n(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)\\r\\n\\r\\n(def camel->keyword (comp keyword\\r\\n                          str/join\\r\\n                          (partial interpose \\\\-)\\r\\n                          (partial map str/lower-case)\\r\\n                          \#(str/split % \#\\"(?<\=[a-z])(?\=[A-Z])\\")))\\r\\n(camel->keyword \\"CamelCase\\")\\r\\n(camel->keyword \\"lowerCamelCase\\")" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])\\r\\n(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])\\r\\n\\r\\n; Define a function literal which forces all arguments to be specified\\r\\n(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])\\r\\n(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)\\r\\n\\r\\n; Use function composition\\r\\n(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)\\r\\n(def camel->keyword (comp keyword\\r\\n                          str/join\\r\\n                          (partial interpose \\\\-)\\r\\n                          (partial map str/lower-case)\\r\\n                          \#(str/split % \#\\"(?<\=[a-z])(?\=[A-Z])\\")))\\r\\n(camel->keyword \\"CamelCase\\")\\r\\n(camel->keyword \\"lowerCamelCase\\")" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])\\r\\n(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])\\r\\n\\r\\n; Define a function literal which forces all arguments to be specified\\r\\n(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])\\r\\n(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)\\r\\n\\r\\n; Use function composition\\r\\n(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)\\r\\n(require '[clojure.string \:as str])\\r\\n(def camel->keyword (comp keyword\\r\\n                          str/join\\r\\n                          (partial interpose \\\\-)\\r\\n                          (partial map str/lower-case)\\r\\n                          \#(str/split % \#\\"(?<\=[a-z])(?\=[A-Z])\\")))\\r\\n(camel->keyword \\"CamelCase\\")\\r\\n(camel->keyword \\"lowerCamelCase\\")" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])\\r\\n(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])\\r\\n\\r\\n; Define a function literal which forces all arguments to be specified\\r\\n(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])\\r\\n(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)\\r\\n\\r\\n; Use function composition\\r\\n(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)\\r\\n(require '[clojure.string \:as str])\\r\\n(def camel->keyword (comp keyword\\r\\n                          str/join\\r\\n                          (partial interpose \\\\-)\\r\\n                          (partial map str/lower-case)\\r\\n                          \#(str/split % \#\\"(?<\=[a-z])(?\=[A-Z])\\")))\\r\\n(camel->keyword \\"CamelCase\\")\\r\\n(camel->keyword \\"lowerCamelCase\\")\\r\\n\\r\\n; Define some higher order functions\\r\\n(defn adder\\r\\n  [n]\\r\\n  (fn [x] (+ n x)))\\r\\n((adder 5) 18)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])\\r\\n(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])\\r\\n\\r\\n; Define a function literal which forces all arguments to be specified\\r\\n(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])\\r\\n(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)\\r\\n\\r\\n; Use function composition\\r\\n(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)\\r\\n(require '[clojure.string \:as str])\\r\\n(def camel->keyword (comp keyword\\r\\n                          str/join\\r\\n                          (partial interpose \\\\-)\\r\\n                          (partial map str/lower-case)\\r\\n                          \#(str/split % \#\\"(?<\=[a-z])(?\=[A-Z])\\")))\\r\\n(camel->keyword \\"CamelCase\\")\\r\\n(camel->keyword \\"lowerCamelCase\\")\\r\\n\\r\\n; Define some higher order functions\\r\\n(defn adder\\r\\n  [x]\\r\\n  (fn [y] (+ x y)))\\r\\n((adder 5) 18)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])\\r\\n(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])\\r\\n\\r\\n; Define a function literal which forces all arguments to be specified\\r\\n(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])\\r\\n(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)\\r\\n\\r\\n; Use function composition\\r\\n(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)\\r\\n(require '[clojure.string \:as str])\\r\\n(def camel->keyword (comp keyword\\r\\n                          str/join\\r\\n                          (partial interpose \\\\-)\\r\\n                          (partial map str/lower-case)\\r\\n                          \#(str/split % \#\\"(?<\=[a-z])(?\=[A-Z])\\")))\\r\\n(camel->keyword \\"CamelCase\\")\\r\\n(camel->keyword \\"lowerCamelCase\\")\\r\\n\\r\\n; Define some higher order functions\\r\\n(defn adder\\r\\n  [x]\\r\\n  (fn [y] (+ x y)))\\r\\n((adder 5) 18)\\r\\n(defn doubler\\r\\n  [f]\\r\\n  (fn [& args]\\r\\n    (* 2 (apply f args))))\\r\\n(def double-+ (doubler +))\\r\\n(double-+ 1 2 3)" "(double-+ 1 2 3 4)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])\\r\\n(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])\\r\\n\\r\\n; Define a function literal which forces all arguments to be specified\\r\\n(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])\\r\\n(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)\\r\\n\\r\\n; Use function composition\\r\\n(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)\\r\\n(require '[clojure.string \:as str])\\r\\n(def camel->keyword (comp keyword\\r\\n                          str/join\\r\\n                          (partial interpose \\\\-)\\r\\n                          (partial map str/lower-case)\\r\\n                          \#(str/split % \#\\"(?<\=[a-z])(?\=[A-Z])\\")))\\r\\n(camel->keyword \\"CamelCase\\")\\r\\n(camel->keyword \\"lowerCamelCase\\")\\r\\n\\r\\n; Define some higher order functions\\r\\n(defn adder\\r\\n  [x]\\r\\n  (fn [y] (+ x y)))\\r\\n((adder 5) 18)\\r\\n(defn doubler\\r\\n  [f]\\r\\n  (fn [& args]\\r\\n    (* 2 (apply f args))))\\r\\n(def double-+ (doubler +))\\r\\n(double-+ 1 2 3)\\r\\n\\r\\n; Define some logger that redirects standard outpu\\r\\n(defn print-logger\\r\\n  [writer]\\r\\n  \#(binding [*out* writer]\\r\\n     (println %)))\\r\\n\\r\\n(def *out*-logger (print-logger *out*))\\r\\n(*out*-logger \\"hello\\")" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])\\r\\n(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])\\r\\n\\r\\n; Define a function literal which forces all arguments to be specified\\r\\n(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])\\r\\n(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)\\r\\n\\r\\n; Use function composition\\r\\n(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)\\r\\n(require '[clojure.string \:as str])\\r\\n(def camel->keyword (comp keyword\\r\\n                          str/join\\r\\n                          (partial interpose \\\\-)\\r\\n                          (partial map str/lower-case)\\r\\n                          \#(str/split % \#\\"(?<\=[a-z])(?\=[A-Z])\\")))\\r\\n(camel->keyword \\"CamelCase\\")\\r\\n(camel->keyword \\"lowerCamelCase\\")\\r\\n\\r\\n; Define some higher order functions\\r\\n(defn adder\\r\\n  [x]\\r\\n  (fn [y] (+ x y)))\\r\\n((adder 5) 18)\\r\\n(defn doubler\\r\\n  [f]\\r\\n  (fn [& args]\\r\\n    (* 2 (apply f args))))\\r\\n(def double-+ (doubler +))\\r\\n(double-+ 1 2 3)\\r\\n\\r\\n; Define some logger that redirects standard output\\r\\n(defn print-logger\\r\\n  [writer]\\r\\n  \#(binding [*out* writer]\\r\\n     (println %)))\\r\\n\\r\\n; Define logger to standard output and use it\\r\\n(def *out*-logger (print-logger *out*))\\r\\n(*out*-logger \\"hello\\")\\r\\n\\r\\n(def writer (java.io.StringWriter.))\\r\\n(def retained-logger (print-logger writer))\\r\\n(retained-logger \\"hello\\")\\r\\n(str writer)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])\\r\\n(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])\\r\\n\\r\\n; Define a function literal which forces all arguments to be specified\\r\\n(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])\\r\\n(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)\\r\\n\\r\\n; Use function composition\\r\\n(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)\\r\\n(require '[clojure.string \:as str])\\r\\n(def camel->keyword (comp keyword\\r\\n                          str/join\\r\\n                          (partial interpose \\\\-)\\r\\n                          (partial map str/lower-case)\\r\\n                          \#(str/split % \#\\"(?<\=[a-z])(?\=[A-Z])\\")))\\r\\n(camel->keyword \\"CamelCase\\")\\r\\n(camel->keyword \\"lowerCamelCase\\")\\r\\n\\r\\n; Define some higher order functions\\r\\n(defn adder\\r\\n  [x]\\r\\n  (fn [y] (+ x y)))\\r\\n((adder 5) 18)\\r\\n(defn doubler\\r\\n  [f]\\r\\n  (fn [& args]\\r\\n    (* 2 (apply f args))))\\r\\n(def double-+ (doubler +))\\r\\n(double-+ 1 2 3)\\r\\n\\r\\n; Define some logger that redirects standard output\\r\\n(defn print-logger\\r\\n  [writer]\\r\\n  \#(binding [*out* writer]\\r\\n     (println %)))\\r\\n\\r\\n; Define logger to standard output and use it\\r\\n(def *out*-logger (print-logger *out*))\\r\\n(*out*-logger \\"hello\\")\\r\\n\\r\\n; Define logger to in-memory buffer\\r\\n(def writer (java.io.StringWriter.))\\r\\n(def retained-logger (print-logger writer))\\r\\n(retained-logger \\"hello\\")\\r\\n(str writer)\\r\\n\\r\\n(require `clojure.java.io)\\r\\n(defn file-logger\\r\\n  [file]\\r\\n  \#(with-open [f (clojure.java.io/writer file \:append true)]\\r\\n     ((print-logger f) %)))" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])\\r\\n(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])\\r\\n\\r\\n; Define a function literal which forces all arguments to be specified\\r\\n(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])\\r\\n(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)\\r\\n\\r\\n; Use function composition\\r\\n(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)\\r\\n(require '[clojure.string \:as str])\\r\\n(def camel->keyword (comp keyword\\r\\n                          str/join\\r\\n                          (partial interpose \\\\-)\\r\\n                          (partial map str/lower-case)\\r\\n                          \#(str/split % \#\\"(?<\=[a-z])(?\=[A-Z])\\")))\\r\\n(camel->keyword \\"CamelCase\\")\\r\\n(camel->keyword \\"lowerCamelCase\\")\\r\\n\\r\\n; Define some higher order functions\\r\\n(defn adder\\r\\n  [x]\\r\\n  (fn [y] (+ x y)))\\r\\n((adder 5) 18)\\r\\n(defn doubler\\r\\n  [f]\\r\\n  (fn [& args]\\r\\n    (* 2 (apply f args))))\\r\\n(def double-+ (doubler +))\\r\\n(double-+ 1 2 3)\\r\\n\\r\\n; Define some logger that redirects standard output\\r\\n(defn print-logger\\r\\n  [writer]\\r\\n  \#(binding [*out* writer]\\r\\n     (println %)))\\r\\n\\r\\n; Define logger to standard output and use it\\r\\n(def *out*-logger (print-logger *out*))\\r\\n(*out*-logger \\"hello\\")\\r\\n\\r\\n; Define logger to in-memory buffer\\r\\n(def writer (java.io.StringWriter.))\\r\\n(def retained-logger (print-logger writer))\\r\\n(retained-logger \\"hello\\")\\r\\n(str writer)\\r\\n\\r\\n(require `clojure.java.io)\\r\\n(defn file-logger\\r\\n  [file]\\r\\n  \#(with-open [f (clojure.java.io/writer file \:append true)]\\r\\n     ((print-logger f) %)))\\r\\n(def log->file (file-logger \\"messages.log\\"))" "(log->file \\"hello\\")" "more messages.log" "% more messages.log" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])\\r\\n(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])\\r\\n\\r\\n; Define a function literal which forces all arguments to be specified\\r\\n(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])\\r\\n(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)\\r\\n\\r\\n; Use function composition\\r\\n(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)\\r\\n(require '[clojure.string \:as str])\\r\\n(def camel->keyword (comp keyword\\r\\n                          str/join\\r\\n                          (partial interpose \\\\-)\\r\\n                          (partial map str/lower-case)\\r\\n                          \#(str/split % \#\\"(?<\=[a-z])(?\=[A-Z])\\")))\\r\\n(camel->keyword \\"CamelCase\\")\\r\\n(camel->keyword \\"lowerCamelCase\\")\\r\\n\\r\\n; Define some higher order functions\\r\\n(defn adder\\r\\n  [x]\\r\\n  (fn [y] (+ x y)))\\r\\n((adder 5) 18)\\r\\n(defn doubler\\r\\n  [f]\\r\\n  (fn [& args]\\r\\n    (* 2 (apply f args))))\\r\\n(def double-+ (doubler +))\\r\\n(double-+ 1 2 3)\\r\\n\\r\\n; Define some logger that redirects standard output\\r\\n(defn print-logger\\r\\n  [writer]\\r\\n  \#(binding [*out* writer]\\r\\n     (println %)))\\r\\n\\r\\n; Define logger to standard output and use it\\r\\n(def *out*-logger (print-logger *out*))\\r\\n(*out*-logger \\"hello\\")\\r\\n\\r\\n; Define logger to in-memory buffer\\r\\n(def writer (java.io.StringWriter.))\\r\\n(def retained-logger (print-logger writer))\\r\\n(retained-logger \\"hello\\")\\r\\n(str writer)\\r\\n\\r\\n; Define logger to file system\\r\\n(require `clojure.java.io)\\r\\n(defn file-logger\\r\\n  [file]\\r\\n  \#(with-open [f (clojure.java.io/writer file \:append true)]\\r\\n     ((print-logger f) %)))\\r\\n(def log->file (file-logger \\"messages.log\\"))\\r\\n(log->file \\"hello\\")\\r\\n\\r\\n; Define logger to accept a sequence of logging functions\\r\\n(defn multi-logger\\r\\n  [& logger-fns]\\r\\n  \#(doseq [f logger-fns]\\r\\n     (f %)))\\r\\n\\r\\n(def log (multi-logger\\r\\n           (print-logger *out*)\\r\\n           (file-logger \\"messages.log\\")))\\r\\n(log \\"hello again\\")" "\\r\\n(defn timestamped-logger\\r\\n  [logger]\\r\\n  \#(logger (format \\"[%1$tY-%1$tm-%1$te %1$tH\:%1$tM\:%1$tS] %2$s\\" (java.util.Date.) %)))\\r\\n(def log-timestamped (timestamped-logger\\r\\n                       (multi-logger\\r\\n                         (print-logger *out*)\\r\\n                         (file-logger \\"messages.log\\"))))\\r\\n(log-timestamped \\"goodbye, now\\")" "; Use memoization with prime functions\\r\\n(defn prime?\\r\\n  [n]\\r\\n  (cond\\r\\n    (\=\= 1 n) false\\r\\n    (\=\= 2 n) true\\r\\n    (even? n) false\\r\\n    \:else (->> (range 3 (inc (Math/sqrt n)) 2)\\r\\n            (filter \#(zero? (rem n %)))\\r\\n            empty?)))\\r\\n(time (prime? 1125899906842679))" "(time (prime? 1125899906842679))" "(time (prime? 1125899906842679))\\r\\n(let [m-prime? (memoize prime?)]\\r\\n  (time m-prime? 1125899906842679)\\r\\n  (time m-prime? 1125899906842679))" "(time (prime? 1125899906842679))\\r\\n(let [m-prime? (memoize prime?)]\\r\\n  (time (m-prime? 1125899906842679))\\r\\n  (time (m-prime? 1125899906842679)))" "(ns chapter-one-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))\\r\\n\\r\\n; Check that comma evalues to whitespace\\r\\n(deftest comma-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= [1 2 3] [,,,1, 2,,, ,,,, 3,,,,,,,,,,,,,,]))))" "(ns chapter-one-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter-one-core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))\\r\\n\\r\\n; Check that comma evalues to whitespace\\r\\n(deftest comma-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= [1 2 3] [,,,1, 2,,, ,,,, 3,,,,,,,,,,,,,,]))))" "(ns chapter-one-core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n(\= (average [60 80 100 400]) 160)\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)\\r\\n(re-seq regex \\"1-3\\")\\r\\n\\r\\n\\r\\n; Use the reader macro\\r\\n(read-string \\"(+ 1 2 \#_(* 2 2) 8)\\")\\r\\n\\r\\n; Use comment\\r\\n(comment (println \\"hello\\"))\\r\\n\\r\\n; Demonstrate the commas evaluate to whitespace\\r\\n(\= [1 2 3] [1, 2, 3])\\r\\n\\r\\n; Show off literal data structure\\r\\n'(a b \:name 12.5) ;; list\\r\\n['a 'b \:name 12.5] ;; vector\\r\\n{\:name \\"Jacob\\" \:age 20} ;; map\\r\\n\#{1 2 3} ;; set\\r\\n\\r\\n; define a variable\\r\\n(def x 1)\\r\\nx ;\= 1\\r\\n\\r\\n; Demonstrate what eval does\\r\\n(eval \:foo) ;\= \:foo\\r\\n(eval [1 2 3]) ;\= [1 2 3]\\r\\n(eval \\"text\\") ;\= \\"text\\"" "(\= (average [60 80 100 400]) 160)" "(ns chapter-one-core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n(\= (average [60 80 100 400]) 160)\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n(\= (read-string \\"42\\") 42)\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n(\= (pr-str [1 2 3]) \\"[1 2 3]\\")\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)\\r\\n(re-seq regex \\"1-3\\")\\r\\n\\r\\n\\r\\n; Use the reader macro\\r\\n(read-string \\"(+ 1 2 \#_(* 2 2) 8)\\")\\r\\n\\r\\n; Use comment\\r\\n(comment (println \\"hello\\"))\\r\\n\\r\\n; Demonstrate the commas evaluate to whitespace\\r\\n(\= [1 2 3] [1, 2, 3])\\r\\n\\r\\n; Show off literal data structure\\r\\n'(a b \:name 12.5) ;; list\\r\\n['a 'b \:name 12.5] ;; vector\\r\\n{\:name \\"Jacob\\" \:age 20} ;; map\\r\\n\#{1 2 3} ;; set\\r\\n\\r\\n; define a variable\\r\\n(def x 1)\\r\\nx ;\= 1\\r\\n\\r\\n; Demonstrate what eval does\\r\\n(eval \:foo) ;\= \:foo\\r\\n(eval [1 2 3]) ;\= [1 2 3]\\r\\n(eval \\"text\\") ;\= \\"text\\"" "(ns chapter-one-core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n(\= (average [60 80 100 400]) 160)\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n(\= (read-string \\"42\\") 42)\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n(\= (pr-str [1 2 3]) \\"[1 2 3]\\")\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n(\= (\:name person) \\"Jacob Malter\\")\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n(\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\")\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)\\r\\n(re-seq regex \\"1-3\\")\\r\\n\\r\\n\\r\\n; Use the reader macro\\r\\n(read-string \\"(+ 1 2 \#_(* 2 2) 8)\\")\\r\\n\\r\\n; Use comment\\r\\n(comment (println \\"hello\\"))\\r\\n\\r\\n; Demonstrate the commas evaluate to whitespace\\r\\n(\= [1 2 3] [1, 2, 3])\\r\\n(\= [1 2 3] [,,,1, 2,,, ,,,, 3,,,,,,,,,,,,,,])\\r\\n\\r\\n; Show off literal data structure\\r\\n'(a b \:name 12.5) ;; list\\r\\n['a 'b \:name 12.5] ;; vector\\r\\n{\:name \\"Jacob\\" \:age 20} ;; map\\r\\n\#{1 2 3} ;; set\\r\\n\\r\\n; define a variable\\r\\n(def x 1)\\r\\nx ;\= 1\\r\\n\\r\\n; Demonstrate what eval does\\r\\n(eval \:foo) ;\= \:foo\\r\\n(eval [1 2 3]) ;\= [1 2 3]\\r\\n(eval \\"text\\") ;\= \\"text\\"" "; operate on a vector\\r\\n(def v [1 2 3])\\r\\n(conj v 4)\\r\\n(conj v 4 5)\\r\\n(seq v)" "(def m {\:a 5 \:b 6})\\r\\n(conj m [\:c 7])\\r\\n(seq m)" "(def s \#{1 2 3})\\r\\n(conj s 10)\\r\\n(conj s 3 4)\\r\\n(seq s)" "(def l `(1 2 3))\\r\\n(conj l 0)\\r\\n(conj l 0 -1)\\r\\n(seq l) ; l is not modified by conj" "(into v [4 5])" "(into v [4 5])\\r\\n(into m [[\:c 7] [\:d 8]])\\r\\n(into \#{1 2} [2 3 4 5 3 3 2])\\r\\n(into [1] {\:a 1 \:b 2})" "(conj `(1 2 3) 4)\\r\\n(into `(1 2 3) [\:a \:b \:c])" "; conj guarantees membership into a collection\\r\\n(conj `(1 2 3) 4)\\r\\n(into `(1 2 3) [\:a \:b \:c])\\r\\n\\r\\n; empty creates an empty version of its parameter data structure\\r\\n(defn swap-pairs\\r\\n  [sequential]\\r\\n  (into (empty sequential)\\r\\n        (interleave\\r\\n          (take-nth 2 (drop 1 sequential))\\r\\n          (take-nth 2 sequential))))\\r\\n(swap-pairs (apply list (range 10)))\\r\\n(swap-pairs (apply vector (range 10)))" "(defn map-map\\r\\n  [f m]\\r\\n  (into (empty m)\\r\\n        (for [[k v] m]\\r\\n          [k (f v)])))\\r\\n(map-map inc (hash-map \:z 5 \:c 6 \:a 0))\\r\\n(map-map inc (sorted-map \:z 5 \:c 6 \:a 0))" "(count [1 2 3])\\r\\n(count {\:a 1 \:b 2 \:c 3})\\r\\n(count \#{1 2 3})\\r\\n(count `(1 2 3))" "(\= [1 2 3] [1,,,,,,,,,,,,,,2,,,,,,,,,,,,,,,3])" "(\= [1 2 3] `(1 2 3))" "(\= [1 2 3] \#{1 2 3})" "(\= {\:a 1 \:b 2 \:c 3} {\:b 2 \:c 3 \:a 1})" "(\= [1 2 3] [1,,,,,,,,,,,,,,2,,,,,,,,,,,,,,,3])\\r\\n(\= {\:a 1 \:b 2 \:c 3} {\:b 2 \:c 3 \:a 1})\\r\\n(\= \#{1 2 3} \#{2 3 1})\\r\\n(\= [1 2 3] `(1 2 3))" "(\= [1 2 3] `(1 2 3))\\r\\n(\= {\:a 1 \:b 2 \:c 3} {\:b 2 \:c 3 \:a 1})\\r\\n(\= \#{1 2 3} \#{2 3 1})\\r\\n(\= `(1 2 3) [1 2 3])" "(ns chapter-three-core)\\r\\n\\r\\n; list\\r\\n`(a b \:name 12.5)\\r\\n\\r\\n; vector\\r\\n['a 'b \:name 12.5]\\r\\n\\r\\n; map\\r\\n{\:name \\"Chas\\" \:age 31}\\r\\n\\r\\n; set\\r\\n\#{1 2 3}\\r\\n\\r\\n; another map\\r\\n{Math/PI \\"~3.14\\"\\r\\n [\:composite \\"key\\"] 42\\r\\n nil \\"nothing\\"}\\r\\n\\r\\n; set of maps\\r\\n\#{{\:first-name \\"chas\\" \:last-name \\"emerick\\"}\\r\\n  {\:first-name \\"brian\\" \:last-name \\"carper\\"}\\r\\n  {\:first-name \\"christophe\\" \:last-name \\"grand\\"}}\\r\\n\\r\\n; operate on a vector\\r\\n(def v [1 2 3])\\r\\n(conj v 4)\\r\\n(conj v 4 5) ; v is not modified by conj\\r\\n(seq v)\\r\\n\\r\\n; same operation works on maps\\r\\n(def m {\:a 5 \:b 6})\\r\\n(conj m [\:c 7])\\r\\n(seq m) ; m is not modified by conj\\r\\n\\r\\n; and sets\\r\\n(def s \#{1 2 3})\\r\\n(conj s 10)\\r\\n(conj s 3 4) ; duplicate elements are not accepted\\r\\n(seq s) ; s is not modified by conj\\r\\n\\r\\n; and lists\\r\\n(def l `(1 2 3))\\r\\n(conj l 0) ; element appened to the front\\r\\n(conj l 0 -1) ; in reverse order\\r\\n(seq l) ; l is not modified by conj\\r\\n\\r\\n; use into which is built from a seq of conjs\\r\\n(into v [4 5])\\r\\n(into m [[\:c 7] [\:d 8]])\\r\\n(into \#{1 2} [2 3 4 5 3 3 2])\\r\\n(into [1] {\:a 1 \:b 2})\\r\\n\\r\\n; collections can [conj seq count empty \=]\\r\\n; conj guarantees membership into a collection\\r\\n(conj `(1 2 3) 4)\\r\\n(into `(1 2 3) [\:a \:b \:c])\\r\\n\\r\\n; empty creates an empty version of its parameter data structure\\r\\n(defn swap-pairs\\r\\n  [sequential]\\r\\n  (into (empty sequential)\\r\\n        (interleave\\r\\n          (take-nth 2 (drop 1 sequential))\\r\\n          (take-nth 2 sequential))))\\r\\n(swap-pairs (apply list (range 10)))\\r\\n(swap-pairs (apply vector (range 10)))\\r\\n(defn map-map\\r\\n  [f m]\\r\\n  (into (empty m)\\r\\n        (for [[k v] m]\\r\\n          [k (f v)])))\\r\\n(map-map inc (hash-map \:z 5 \:c 6 \:a 0))\\r\\n(map-map inc (sorted-map \:z 5 \:c 6 \:a 0))\\r\\n\\r\\n; count indicates the number of entries\\r\\n(count [1 2 3])\\r\\n(count {\:a 1 \:b 2 \:c 3})\\r\\n(count \#{1 2 3})\\r\\n(count `(1 2 3))\\r\\n\\r\\n; \= indicates equality of entries\\r\\n(\= [1 2 3] `(1 2 3))\\r\\n(\= {\:a 1 \:b 2 \:c 3} {\:b 2 \:c 3 \:a 1})\\r\\n(\= \#{1 2 3} \#{2 3 1})\\r\\n(\= `(1 2 3) [1 2 3])\\r\\n\\r\\n; sequences can [seq first rest next lazy-seq]\\r\\n; seq produces a sequence over its argument\\r\\n(seq \\"Clojure\\")\\r\\n(seq {\:a 5 \:b 6})\\r\\n(seq (java.util.ArrayList. (range 5)))\\r\\n(seq (into-array [\\"Clojure\\" \\"Programming\\"]))\\r\\n(seq [])\\r\\n(seq nil)\\r\\n\\r\\n; some functions call seq on their arguments\\r\\n(map str \\"Clojure\\")\\r\\n(set \\"Programming\\")\\r\\n\\r\\n; [first rest next] provide sequence operations\\r\\n(first \\"Clojure\\")\\r\\n(rest \\"Clojure\\")\\r\\n(next \\"Clojure\\")\\r\\n\\r\\n; rest and next only differ on sequences of zero or one value\\r\\n(rest [1]) ; ()\\r\\n(next [1]) ; nil\\r\\n(rest nil) ; ()\\r\\n(next nil) ; nil\\r\\n\\r\\n; seqs are immutable\\r\\n(doseq [x (range 3)]\\r\\n  (println x))\\r\\n\\r\\n; sequences are not iterators, hence r and rst are not modified\\r\\n(let [r (range 3)\\r\\n      rst (rest r)]\\r\\n  (prn (map str rst))\\r\\n  (prn (map \#(+ 100 %) r))\\r\\n  (prn (conj r -1) (conj rst 42)))\\r\\n\\r\\n; sequences are not lists, hence count requires a full traversal\\r\\n(let [s (range 1e6)]\\r\\n  (time (count s))) ; Elapsed time\: 67.472508 msecs\\r\\n(let [s (apply list (range 1e6))]\\r\\n  (time (count s))) ; Elapsed time\: 0.021668 msecs\\r\\n\\r\\n; create seq with cons or list*\\r\\n(cons 0 (range 1 5)) ; accepts a head element and tail seq\\r\\n(cons \:a [\:b \:c \:d]) ; disregards tail's concrete type\\r\\n(cons 0 (cons 1 (cons 2 (cons 3 (cons 4 (cons 5 (range 6 10)))))))\\r\\n(list* 0 1 2 3 4 5 (range 6 10)) ; list* is equivalent to multiple cons calls\\r\\n\\r\\n; lazy-seq elements only realized when needed\\r\\n(lazy-seq [1 2 3])\\r\\n(defn random-ints\\r\\n  \\"Returns a lazy seq of random integers in the range [0, limit).\\"\\r\\n  [limit]\\r\\n  (lazy-seq\\r\\n    (println \\"realizing random number\\")\\r\\n    (cons (rand-int limit)\\r\\n          (random-ints limit))))\\r\\n(def rands (take 10 (random-ints 50)))\\r\\n(first rands) ; realize the first rand by first call\\r\\n(nth rands 3) ; all preceding values must be realized\\r\\n(count rands) ; count forces entire sequence to be realized\\r\\n(count rands) ; count of rands already realized\\r\\n\\r\\n; there is a better way to do random-ints\\r\\n(repeatedly 10 (partial rand-int 50))\\r\\n\\r\\n; rest is more lazy than next\\r\\n(def x (next (random-ints 50)))\\r\\n(def x (rest (random-ints 50)))\\r\\n\\r\\n; dorun and doall force the realization of the sequence\\r\\n(dorun (take 5 (random-ints 50)))\\r\\n\\r\\n; extract a sequence, process it, turn it back into a more appropriate data structure\\r\\n(apply str (remove (set \\"aeiouy\\") \\r\\n                   \\"Clojure Programming\\"))\\r\\n\\r\\n; lazy-sequences are persistent, so there might be out-of-memory errors without GC\\r\\n(split-with neg? (range -5 5)) ; splits a seq into two lazy seq\\r\\n(let [[t d] (split-with \#(< % 12) (range 1e8))]\\r\\n  [(count t) (count d)]) ; reverseing count t and count d WILL crash computer\\r\\n\\r\\n; maps can [assoc dissoc get contains?]\\r\\n(def m {\:a 1 \:b 2 \:c 3})\\r\\n(get m \:b) ; 2\\r\\n(get m \:d) ; nil\\r\\n(get m \:d \\"notta\\") ; \\"notta\\"\\r\\n(assoc m \:d 4) ; {\:c 3 \:b 2 \:d 4 \:a 1}\\r\\n(dissoc m \:b) ; {\:c 3 \:a 1}\\r\\n\\r\\n; assoc and dissoc work on multiple entries\\r\\n(assoc m\\r\\n       \:x 4\\r\\n       \:y 5\\r\\n       \:z 6) ; {\:y 5 \:z 6 \:c 3 \:b 2 \:x 4 \:a 1}\\r\\n(dissoc m\\r\\n        \:a\\r\\n        \:c) ; {\:b 2}\\r\\n\\r\\n; get and assoc work with vectors too\\r\\n(def v [1 2 3])\\r\\n(get v 1) ; 2 ; v associates the index 1 with the value 2\\r\\n(get v 10) ; nil\\r\\n(get v 10 \\"zipple\\")\\r\\n(assoc v\\r\\n       1 4\\r\\n       0 -12\\r\\n       2 \:p) ; [-12 4 \:p]\\r\\n\\r\\n; assoc can append elements to a vector with the new value's index\\r\\n(assoc v 3 10)\\r\\n(assoc v (count v) 10)\\r\\n\\r\\n; get works with sets\\r\\n(get \#{1 2 3} 2) ; 2\\r\\n(get \#{1 2 3} 4) ; nil\\r\\n(get \#{1 2 3} 4 \\"zilch\\") ; \\"zilch\\"\\r\\n(when (get \#{1 2 3} 2)\\r\\n  (println \\"it contains '2'\!\\")) ; it contains '2'\!\\r\\n\\r\\n; contains checks for a key (and not a value)\\r\\n(contains? [1 2 3] 0) ; true ; checks for the 0 index\\r\\n(contains? {\:a 5 \:b 6} \:b) ; true ; checks for the \:b key\\r\\n(contains? {\:a 5 \:b 6} 42) ; false\\r\\n(contains? \#{1 2 3} 2) ; true\\r\\n\\r\\n; get and contains work on [vectors maps sets Java-maps Strings Java-arrays]\\r\\n(get \\"Jacob\\" 3) ; o\\r\\n(contains? (java.util.HashMap.) \\"not-there\\") ; false\\r\\n(get (into-array [1 2 3]) 0) ; 1\\r\\n\\r\\n; get might not be able to determine whether there is an association\\r\\n(get {\:ethel nil} \:lucy)\\r\\n(get {\:ethel nil} \:ethel)\\r\\n\\r\\n; find works like get but it returns the entry if present\\r\\n(find {\:ethel nil} \:lucy)\\r\\n(find {\:ethel nil} \:ethel)\\r\\n\\r\\n; find works well with destructuring and conditionals\\r\\n(if-let [e (find {\:a 5 \:b 6} \:a)]\\r\\n  (format \\"found %s \=> %s\\" (key e) (val e))\\r\\n  \\"not found\\") ; \\"found \:a \=> 5\\"\\r\\n(if-let [[k v] (find {\:a 5 \:b 6} \:a)]\\r\\n  (format \\"found %s \=> %s\\" k v)\\r\\n  \\"not found\\") ; \\"found \:a \=> 5\\"\\r\\n\\r\\n; nth is similar to get, but nth is more specific\\r\\n(nth [\:a \:b \:c] 2) ; \:c\\r\\n(get [\:a \:b \:c] 2) ; \:c\\r\\n(nth [\:a \:b \:c] 3) ; IndexOutOfBoundsException\\r\\n(get [\:a \:b \:c] 3) ; nil\\r\\n(nth [\:a \:b \:c] -1) ; IndexOutOfBoundsException\\r\\n(get [\:a \:b \:c] -1) ; nil\\r\\n\\r\\n; nth and get are identical when there is a default return value\\r\\n(nth [\:a \:b \:c] -1 \:default)\\r\\n(get [\:a \:b \:c] -1 \:default)\\r\\n\\r\\n; get gracefully handles things that don't support get\\r\\n(nth 42 0) ; UnsupportedOperationException\\r\\n(get 42 0) ; nil\\r\\n\\r\\n; stacks are supported with [conj pop peek] which do what you'd expect\\r\\n; use list\\r\\n(conj '() 1) ; (1)\\r\\n(conj '(2 1) 3) ; (3 2 1)\\r\\n(peek '(3 2 1)) ; 3\\r\\n(pop '(3 2 1)) ; (2 1)\\r\\n(pop '(1)) ; ()\\r\\n(pop '()) ; IllegalStateException\\r\\n\\r\\n; use vector\\r\\n(conj [] 1) ; [1]\\r\\n(conj [1 2] 3) ; [3 2 1]\\r\\n(peek [1 2 3]) ; 3\\r\\n(pop [1 2 3]) ; [1 2]\\r\\n(pop [1]) ; []\\r\\n(pop []) ; IllegalStateException\\r\\n\\r\\n; sets are maps that associate elements to themselves\\r\\n(get \#{1 2 3} 2) ; 2" "(disj \#{1 2 3} 3 1)"]
eclipse.preferences.version=1
