cmdhistory=["foo" "foo()" "(foo)" "(foo \\"Something\\")" "(foo \\"Here is an arg\\")" "\#'user/foo" "(ns clojure-programming.core)\\r\\n\\r\\n(defn foo\\r\\n  \\"I don't do a whole lot.\\"\\r\\n  [x]\\r\\n  (println x \\"Hello, World\!\\"))" "(foo \\"test\\")" "(ns clojure-programming.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [clojure-programming.core \:refer \:all]))\\r\\n\\r\\n(deftest a-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= 0 1))))" "(a-test)" "(ns chapter_one)\\r\\n\\r\\n(defn foo\\r\\n  \\"I don't do a whole lot.\\"\\r\\n  [x]\\r\\n  (println x \\"Hello, World\!\\"))" "(foo \\"\\")" "(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + number) (count numbers))" "(ns chapter_one.core)\\r\\n\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + number) (count numbers))" "(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + number) (count numbers)))" "(ns chapter_one.core)\\r\\n\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + number) (count numbers)))" "(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))" "(ns chapter_one.core)\\r\\n\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n(average [60 80 100 400])" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n(deftest average\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))" "(average-test)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 161))))" "(average-test)" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n(read-string \\"42\\")\\r\\n\\r\\n(read-string \\"(+ 1 2)\\")" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") \\"42\\"))))" "(read-string-test)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))" "(read-string-test\\n  )" "(read-string-test)" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])" "(pr-str [1 2 3])" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))" "()(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))" "(pr-str-test)" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"" "\\"multiline stings\\r\\nare easy to declare\\"" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare a character literal\\r\\n(class \\\\c)" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c)\\r\\n\\\\u00ff\\r\\n\\\\o41" "(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})" "(\:city person)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))" "(keyword-test)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:user/location) \\"35.779385, -78.675592\\"))))" "(namespace-test)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:user/location calzones) \\"35.779385, -78.675592\\"))))" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday" "(namespace-test)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:user/location calzones) \\"35.779385, -78.675592\\"))))" "(namespace-test)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:/location calzones) \\"35.779385, -78.675592\\"))))" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core-test/location calzones) \\"35.779385, -78.675592\\"))))" "(namespace-test\\n  )" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one/location calzones) \\"35.779385, -78.675592\\"))))" "(namespace-test)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))" "(namespace-test)" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))\\r\\n\\r\\n; Check that regex has been declared\\r\\n(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\"([\\"1-3\\" \\"1\\" \\"3\\"])\\"))))" "(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\"([\\"1-3\\" \\"1\\" \\"3\\"])\\"))))" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))\\r\\n\\r\\n; Check that regex has been declared\\r\\n(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\"([\\"1-3\\" \\"1\\" \\"3\\"])\\"))))" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))\\r\\n\\r\\n; Check that regex has been declared\\r\\n(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\"([1-3 1 3])\\"))))" "(regex-test)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))\\r\\n\\r\\n; Check that regex has been declared\\r\\n(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\"([\\\\\\"1-3\\\\\\" \\\\\\"1\\\\\\" \\\\\\"3\\\\\\"])\\"))))" "(regex-test)" "(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\"([\\"1-3\\" \\"1\\" \\"3\\"])\\"))))" "(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\"([\\\\\\"1-3\\\\\\" \\\\\\"1\\\\\\" \\\\\\"3\\\\\\"])\\"))))" "(regex-test)" "(re-seq regex \\"1-3\\")" "(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\"([\\"1-3\\" \\"1\\" \\"3\\"])\\"))))" "(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\"([\\"\\"1-3\\"\\" \\"\\"1\\"\\" \\"\\"3\\"\\"])\\"))))" "(regex-test)" "(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\"([\\"\\\\1\\\\-\\\\3\\" \\"\\\\1\\" \\"\\\\3\\"])\\"))))" "(regex-test)" "(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") ([\\"1-3\\" \\"1\\" \\"3\\"])))))" "(regex-test)" "(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\\\\\"([\\"1-3\\" \\"1\\" \\"3\\"])\\\\\\"))))" "(regex-test)" "([\\"1-3\\" \\"1\\" \\"3\\"])" "([1-3 1 3])" "\\n\\"([\\"1-3\\" \\"1\\" \\"3\\"])\\"" "\\"([\\\\\\"1-3\\\\\\" \\\\\\"1\\\\\\" \\\\\\"3\\\\\\"])\\"" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))\\r\\n\\r\\n; Check that regex has been declared\\r\\n(deftest regex-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (re-seq regex \\"1-3\\") \\"([\\\\\\"1-3\\\\\\" \\\\\\"1\\\\\\" \\\\\\"3\\\\\\"])\\"))))" "(regex-test)" " (is (\= (re-seq regex \\"1-3\\") \\"([\\\\\\"1-3\\\\\\" \\\\\\"1\\\\\\" \\\\\\"3\\\\\\"])\\"))" " \\n (\= (re-seq regex \\"1-3\\") \\"([\\\\\\"1-3\\\\\\" \\\\\\"1\\\\\\" \\\\\\"3\\\\\\"])\\")" "(re-seq regex \\"1-3\\")" "\\"([\\\\\\"1-3\\\\\\" \\\\\\"1\\\\\\" \\\\\\"3\\\\\\"])\\"" "([\\\\\\"1-3\\\\\\" \\\\\\"1\\\\\\" \\\\\\"3\\\\\\"])" "([\\"1-3\\" \\"1\\" \\"3\\"])" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)\\r\\n(re-seq regex \\"1-3\\")" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)\\r\\n(re-seq regex \\"1-3\\")\\r\\n\\r\\n; Use the reader macro\\r\\n(read-string \\"(+ 1 2 \#_(* 2 2) 8)\\")" "; Use comment\\r\\n(comment (println \\"hello\\"))" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)\\r\\n(re-seq regex \\"1-3\\")\\r\\n\\r\\n\\r\\n; Use the reader macro\\r\\n(read-string \\"(+ 1 2 \#_(* 2 2) 8)\\")\\r\\n\\r\\n; Use comment\\r\\n(comment (println \\"hello\\"))\\r\\n\\r\\n; Demonstrate the commas evaluate to whitespace\\r\\n(\= [1 2 3] [1, 2, 3])" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))\\r\\n\\r\\n; Check that comma evalues to whitespace\\r\\n(deftest comma-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= ([1 2 3] [,,1,,, 2,, 3,,,,,,]))))" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))\\r\\n\\r\\n; Check that comma evalues to whitespace\\r\\n(deftest comma-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= ([1 2 3] [1, 2, 3])))))" "(comma-test)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))\\r\\n\\r\\n; Check that comma evalues to whitespace\\r\\n(deftest comma-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= [1 2 3] [1, 2, 3]))))" "(comma-test)" "(ns chapter_one.core-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))\\r\\n\\r\\n; Check that comma evalues to whitespace\\r\\n(deftest comma-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= [1 2 3] [,,,1, 2,,, ,,,, 3,,,,,,,,,,,,,,]))))" "(comma-test)" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)\\r\\n(re-seq regex \\"1-3\\")\\r\\n\\r\\n\\r\\n; Use the reader macro\\r\\n(read-string \\"(+ 1 2 \#_(* 2 2) 8)\\")\\r\\n\\r\\n; Use comment\\r\\n(comment (println \\"hello\\"))\\r\\n\\r\\n; Demonstrate the commas evaluate to whitespace\\r\\n(\= [1 2 3] [1, 2, 3])\\r\\n\\r\\n; Show off literal data structure\\r\\n'(a b \:name 12.5) ;; list\\r\\n['a 'b \:name 12.5] ;; vector\\r\\n{\:name \\"Chas\\" \:age 31} ;; map\\r\\n\#{1 2 3} ;; set" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)\\r\\n(re-seq regex \\"1-3\\")\\r\\n\\r\\n\\r\\n; Use the reader macro\\r\\n(read-string \\"(+ 1 2 \#_(* 2 2) 8)\\")\\r\\n\\r\\n; Use comment\\r\\n(comment (println \\"hello\\"))\\r\\n\\r\\n; Demonstrate the commas evaluate to whitespace\\r\\n(\= [1 2 3] [1, 2, 3])\\r\\n\\r\\n; Show off literal data structure\\r\\n'(a b \:name 12.5) ;; list\\r\\n['a 'b \:name 12.5] ;; vector\\r\\n{\:name \\"Jacob\\" \:age 20} ;; map\\r\\n\#{1 2 3} ;; set\\r\\n\\r\\n; define a variable\\r\\n(def x 1)" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)\\r\\n(re-seq regex \\"1-3\\")\\r\\n\\r\\n\\r\\n; Use the reader macro\\r\\n(read-string \\"(+ 1 2 \#_(* 2 2) 8)\\")\\r\\n\\r\\n; Use comment\\r\\n(comment (println \\"hello\\"))\\r\\n\\r\\n; Demonstrate the commas evaluate to whitespace\\r\\n(\= [1 2 3] [1, 2, 3])\\r\\n\\r\\n; Show off literal data structure\\r\\n'(a b \:name 12.5) ;; list\\r\\n['a 'b \:name 12.5] ;; vector\\r\\n{\:name \\"Jacob\\" \:age 20} ;; map\\r\\n\#{1 2 3} ;; set\\r\\n\\r\\n; define a variable\\r\\n(def x 1)\\r\\nx" "(ns chapter_one.core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)\\r\\n(re-seq regex \\"1-3\\")\\r\\n\\r\\n\\r\\n; Use the reader macro\\r\\n(read-string \\"(+ 1 2 \#_(* 2 2) 8)\\")\\r\\n\\r\\n; Use comment\\r\\n(comment (println \\"hello\\"))\\r\\n\\r\\n; Demonstrate the commas evaluate to whitespace\\r\\n(\= [1 2 3] [1, 2, 3])\\r\\n\\r\\n; Show off literal data structure\\r\\n'(a b \:name 12.5) ;; list\\r\\n['a 'b \:name 12.5] ;; vector\\r\\n{\:name \\"Jacob\\" \:age 20} ;; map\\r\\n\#{1 2 3} ;; set\\r\\n\\r\\n; define a variable\\r\\n(def x 1)\\r\\nx ;\= 1\\r\\n\\r\\n; Demonstrate what eval does\\r\\n(eval \:foo) ;\= \:foo\\r\\n(eval [1 2 3]) ;\= [1 2 3]\\r\\n(eval \\"text\\") ;\= \\"text\\"" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (do-something-with-a-number a)\\r\\n  (\= a 5))" "(let [a 5]\\r\\n  (do-something-with-a-number a)\\r\\n  (\= a 5))" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n(def five (StatefulInteger. 5))\\r\\n;\= \#'user/five\\r\\n(def six (StatefulInteger. 6))\\r\\n;\= \#'user/six\\r\\n(.intValue five)\\r\\n;\= 5\\r\\n(\= five six)\\r\\n;\= false\\r\\n(.setInt five 6)\\r\\n;\= nil\\r\\n(\= five six)" "(def five (StatefulInteger. 5))\\r\\n;\= \#'user/five\\r\\n(def six (StatefulInteger. 6))" "(StatefulInteger. 5)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n(import chapter_two.StatefulInteger)\\r\\n\\r\\n(def five (StatefulInteger. 5))\\r\\n;\= \#'user/five\\r\\n(def six (StatefulInteger. 6))\\r\\n;\= \#'user/six\\r\\n(.intValue five)\\r\\n;\= 5\\r\\n(\= five six)\\r\\n;\= false\\r\\n(.setInt five 6)\\r\\n;\= nil\\r\\n(\= five six)" "(StatefulInteger. 5\\n                  )" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; run example code\\r\\n(import chapter_two.StatefulInteger)\\r\\n(def five (new StatefulInteger 5))\\r\\n(def six (new StatefulInteger 6))\\r\\n(.intValue five)\\r\\n(\= five six)\\r\\n(.setState five 6)\\r\\n(\= five six)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; run example code\\r\\n(import chapter_two.StatefulInteger)\\r\\n(def five (new StatefulInteger 5))\\r\\n(def six (new StatefulInteger 6))\\r\\n(. intValue five)\\r\\n(\= five six)\\r\\n(. setState five 6)\\r\\n(\= five six)" "(. five intValue)\\r\\n(\= five six)\\r\\n(. five setState 6)\\r\\n(\= five six)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; run example code\\r\\n(import chapter_two.StatefulInteger)\\r\\n(def five (new StatefulInteger 5))\\r\\n(def six (new StatefulInteger 6))\\r\\n(. five intValue)\\r\\n(\= five six)\\r\\n(. five setState 6)\\r\\n(\= five six)" "(. five intValue)\\r\\n(\= five six)\\r\\n(. five setState 6)\\r\\n(\= five six)" "(. five intValue)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; run example code\\r\\n(import chapter_two.StatefulInteger)\\r\\n(def five (new StatefulInteger 5))\\r\\n(def six (new StatefulInteger 6))\\r\\n(. intValue filve)\\r\\n(\= five six)\\r\\n(. setState five 6)\\r\\n(\= five six)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; run example code\\r\\n(import chapter_two.StatefulInteger)\\r\\n(def five (new StatefulInteger 5))\\r\\n(def six (new StatefulInteger 6))\\r\\n(. intValue five)\\r\\n(\= five six)\\r\\n(. setState five 6)\\r\\n(\= five six)" "(. intValue five)" "(import chapter_two.StatefulInteger)\\r\\n(def five (new StatefulInteger 5))\\r\\n(def six (new StatefulInteger 6))\\r\\n(. intValue five)" "(. intValue five)" "(.intValue five)" "(import chapter_two.StatefulInteger)\\r\\n(def five (new StatefulInteger 5))\\r\\n(def six (new StatefulInteger 6))\\r\\n(.intValue five)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; run example code\\r\\n(import chapter_two.StatefulInteger)\\r\\n(def five (StatefulInteger. 5))\\r\\n(def six (StatefulInteger. 6))\\r\\n(.intValue five)\\r\\n(\= five six)\\r\\n(.setState five 6)\\r\\n(\= five six)" "(.intValue five)" "(def five (StatefulInteger. 5))\\r\\n(def six (StatefulInteger. 6))\\r\\n(.intValue five)" "(import chapter_two.StatefulInteger)\\r\\n(def five (StatefulInteger. 5))\\r\\n(def six (StatefulInteger. 6))\\r\\n(.intValue five)" "(import chapter_two.StatefulInteger)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; run example code\\r\\n(def five (StatefulInteger. 5))\\r\\n(def six (StatefulInteger. 6))\\r\\n(.intValue five)\\r\\n(\= five six)\\r\\n(.setState five 6)\\r\\n(\= five six)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)" "(call-twice println 123)" "(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\"\\r\\n \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4] [5 6 7 8])" "(map * [1 2 3 4] [5 6 7 8 9])" "(map * [1 2 3 4 5] [5 6 7 8 9])" "(map * [1 2 3 4 5 6] [5 6 7 8 9])" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\"\\r\\n \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])" "(reduce max [0 -3 10 48])" "(reduce + 50 [1 2 3 4])" "(reduce\\r\\n (fn [m v]\\r\\n   (assoc m v (* v v)))  \\r\\n {}\\r\\n [1 2 3 4])" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])" "(apply hash-map [\:a 5 \:b 6])" "(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])" "(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])" "(\#(filter % [\\"a\\" 5 \\"b\\" 6]) string?)" "(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)" "(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])\\r\\n(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])\\r\\n\\r\\n; Define a function literal which forces all arguments to be specified\\r\\n(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])\\r\\n(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)\\r\\n\\r\\n; Use function composition\\r\\n(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)\\r\\n\\r\\n(def camel->keyword (comp keyword\\r\\n                          str/join\\r\\n                          (partial interpose \\\\-)\\r\\n                          (partial map str/lower-case)\\r\\n                          \#(str/split % \#\\"(?<\=[a-z])(?\=[A-Z])\\")))\\r\\n(camel->keyword \\"CamelCase\\")\\r\\n(camel->keyword \\"lowerCamelCase\\")" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])\\r\\n(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])\\r\\n\\r\\n; Define a function literal which forces all arguments to be specified\\r\\n(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])\\r\\n(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)\\r\\n\\r\\n; Use function composition\\r\\n(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)\\r\\n(def camel->keyword (comp keyword\\r\\n                          str/join\\r\\n                          (partial interpose \\\\-)\\r\\n                          (partial map str/lower-case)\\r\\n                          \#(str/split % \#\\"(?<\=[a-z])(?\=[A-Z])\\")))\\r\\n(camel->keyword \\"CamelCase\\")\\r\\n(camel->keyword \\"lowerCamelCase\\")" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])\\r\\n(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])\\r\\n\\r\\n; Define a function literal which forces all arguments to be specified\\r\\n(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])\\r\\n(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)\\r\\n\\r\\n; Use function composition\\r\\n(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)\\r\\n(require '[clojure.string \:as str])\\r\\n(def camel->keyword (comp keyword\\r\\n                          str/join\\r\\n                          (partial interpose \\\\-)\\r\\n                          (partial map str/lower-case)\\r\\n                          \#(str/split % \#\\"(?<\=[a-z])(?\=[A-Z])\\")))\\r\\n(camel->keyword \\"CamelCase\\")\\r\\n(camel->keyword \\"lowerCamelCase\\")" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])\\r\\n(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])\\r\\n\\r\\n; Define a function literal which forces all arguments to be specified\\r\\n(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])\\r\\n(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)\\r\\n\\r\\n; Use function composition\\r\\n(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)\\r\\n(require '[clojure.string \:as str])\\r\\n(def camel->keyword (comp keyword\\r\\n                          str/join\\r\\n                          (partial interpose \\\\-)\\r\\n                          (partial map str/lower-case)\\r\\n                          \#(str/split % \#\\"(?<\=[a-z])(?\=[A-Z])\\")))\\r\\n(camel->keyword \\"CamelCase\\")\\r\\n(camel->keyword \\"lowerCamelCase\\")\\r\\n\\r\\n; Define some higher order functions\\r\\n(defn adder\\r\\n  [n]\\r\\n  (fn [x] (+ n x)))\\r\\n((adder 5) 18)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])\\r\\n(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])\\r\\n\\r\\n; Define a function literal which forces all arguments to be specified\\r\\n(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])\\r\\n(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)\\r\\n\\r\\n; Use function composition\\r\\n(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)\\r\\n(require '[clojure.string \:as str])\\r\\n(def camel->keyword (comp keyword\\r\\n                          str/join\\r\\n                          (partial interpose \\\\-)\\r\\n                          (partial map str/lower-case)\\r\\n                          \#(str/split % \#\\"(?<\=[a-z])(?\=[A-Z])\\")))\\r\\n(camel->keyword \\"CamelCase\\")\\r\\n(camel->keyword \\"lowerCamelCase\\")\\r\\n\\r\\n; Define some higher order functions\\r\\n(defn adder\\r\\n  [x]\\r\\n  (fn [y] (+ x y)))\\r\\n((adder 5) 18)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])\\r\\n(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])\\r\\n\\r\\n; Define a function literal which forces all arguments to be specified\\r\\n(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])\\r\\n(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)\\r\\n\\r\\n; Use function composition\\r\\n(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)\\r\\n(require '[clojure.string \:as str])\\r\\n(def camel->keyword (comp keyword\\r\\n                          str/join\\r\\n                          (partial interpose \\\\-)\\r\\n                          (partial map str/lower-case)\\r\\n                          \#(str/split % \#\\"(?<\=[a-z])(?\=[A-Z])\\")))\\r\\n(camel->keyword \\"CamelCase\\")\\r\\n(camel->keyword \\"lowerCamelCase\\")\\r\\n\\r\\n; Define some higher order functions\\r\\n(defn adder\\r\\n  [x]\\r\\n  (fn [y] (+ x y)))\\r\\n((adder 5) 18)\\r\\n(defn doubler\\r\\n  [f]\\r\\n  (fn [& args]\\r\\n    (* 2 (apply f args))))\\r\\n(def double-+ (doubler +))\\r\\n(double-+ 1 2 3)" "(double-+ 1 2 3 4)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])\\r\\n(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])\\r\\n\\r\\n; Define a function literal which forces all arguments to be specified\\r\\n(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])\\r\\n(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)\\r\\n\\r\\n; Use function composition\\r\\n(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)\\r\\n(require '[clojure.string \:as str])\\r\\n(def camel->keyword (comp keyword\\r\\n                          str/join\\r\\n                          (partial interpose \\\\-)\\r\\n                          (partial map str/lower-case)\\r\\n                          \#(str/split % \#\\"(?<\=[a-z])(?\=[A-Z])\\")))\\r\\n(camel->keyword \\"CamelCase\\")\\r\\n(camel->keyword \\"lowerCamelCase\\")\\r\\n\\r\\n; Define some higher order functions\\r\\n(defn adder\\r\\n  [x]\\r\\n  (fn [y] (+ x y)))\\r\\n((adder 5) 18)\\r\\n(defn doubler\\r\\n  [f]\\r\\n  (fn [& args]\\r\\n    (* 2 (apply f args))))\\r\\n(def double-+ (doubler +))\\r\\n(double-+ 1 2 3)\\r\\n\\r\\n; Define some logger that redirects standard outpu\\r\\n(defn print-logger\\r\\n  [writer]\\r\\n  \#(binding [*out* writer]\\r\\n     (println %)))\\r\\n\\r\\n(def *out*-logger (print-logger *out*))\\r\\n(*out*-logger \\"hello\\")" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])\\r\\n(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])\\r\\n\\r\\n; Define a function literal which forces all arguments to be specified\\r\\n(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])\\r\\n(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)\\r\\n\\r\\n; Use function composition\\r\\n(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)\\r\\n(require '[clojure.string \:as str])\\r\\n(def camel->keyword (comp keyword\\r\\n                          str/join\\r\\n                          (partial interpose \\\\-)\\r\\n                          (partial map str/lower-case)\\r\\n                          \#(str/split % \#\\"(?<\=[a-z])(?\=[A-Z])\\")))\\r\\n(camel->keyword \\"CamelCase\\")\\r\\n(camel->keyword \\"lowerCamelCase\\")\\r\\n\\r\\n; Define some higher order functions\\r\\n(defn adder\\r\\n  [x]\\r\\n  (fn [y] (+ x y)))\\r\\n((adder 5) 18)\\r\\n(defn doubler\\r\\n  [f]\\r\\n  (fn [& args]\\r\\n    (* 2 (apply f args))))\\r\\n(def double-+ (doubler +))\\r\\n(double-+ 1 2 3)\\r\\n\\r\\n; Define some logger that redirects standard output\\r\\n(defn print-logger\\r\\n  [writer]\\r\\n  \#(binding [*out* writer]\\r\\n     (println %)))\\r\\n\\r\\n; Define logger to standard output and use it\\r\\n(def *out*-logger (print-logger *out*))\\r\\n(*out*-logger \\"hello\\")\\r\\n\\r\\n(def writer (java.io.StringWriter.))\\r\\n(def retained-logger (print-logger writer))\\r\\n(retained-logger \\"hello\\")\\r\\n(str writer)" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])\\r\\n(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])\\r\\n\\r\\n; Define a function literal which forces all arguments to be specified\\r\\n(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])\\r\\n(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)\\r\\n\\r\\n; Use function composition\\r\\n(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)\\r\\n(require '[clojure.string \:as str])\\r\\n(def camel->keyword (comp keyword\\r\\n                          str/join\\r\\n                          (partial interpose \\\\-)\\r\\n                          (partial map str/lower-case)\\r\\n                          \#(str/split % \#\\"(?<\=[a-z])(?\=[A-Z])\\")))\\r\\n(camel->keyword \\"CamelCase\\")\\r\\n(camel->keyword \\"lowerCamelCase\\")\\r\\n\\r\\n; Define some higher order functions\\r\\n(defn adder\\r\\n  [x]\\r\\n  (fn [y] (+ x y)))\\r\\n((adder 5) 18)\\r\\n(defn doubler\\r\\n  [f]\\r\\n  (fn [& args]\\r\\n    (* 2 (apply f args))))\\r\\n(def double-+ (doubler +))\\r\\n(double-+ 1 2 3)\\r\\n\\r\\n; Define some logger that redirects standard output\\r\\n(defn print-logger\\r\\n  [writer]\\r\\n  \#(binding [*out* writer]\\r\\n     (println %)))\\r\\n\\r\\n; Define logger to standard output and use it\\r\\n(def *out*-logger (print-logger *out*))\\r\\n(*out*-logger \\"hello\\")\\r\\n\\r\\n; Define logger to in-memory buffer\\r\\n(def writer (java.io.StringWriter.))\\r\\n(def retained-logger (print-logger writer))\\r\\n(retained-logger \\"hello\\")\\r\\n(str writer)\\r\\n\\r\\n(require `clojure.java.io)\\r\\n(defn file-logger\\r\\n  [file]\\r\\n  \#(with-open [f (clojure.java.io/writer file \:append true)]\\r\\n     ((print-logger f) %)))" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])\\r\\n(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])\\r\\n\\r\\n; Define a function literal which forces all arguments to be specified\\r\\n(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])\\r\\n(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)\\r\\n\\r\\n; Use function composition\\r\\n(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)\\r\\n(require '[clojure.string \:as str])\\r\\n(def camel->keyword (comp keyword\\r\\n                          str/join\\r\\n                          (partial interpose \\\\-)\\r\\n                          (partial map str/lower-case)\\r\\n                          \#(str/split % \#\\"(?<\=[a-z])(?\=[A-Z])\\")))\\r\\n(camel->keyword \\"CamelCase\\")\\r\\n(camel->keyword \\"lowerCamelCase\\")\\r\\n\\r\\n; Define some higher order functions\\r\\n(defn adder\\r\\n  [x]\\r\\n  (fn [y] (+ x y)))\\r\\n((adder 5) 18)\\r\\n(defn doubler\\r\\n  [f]\\r\\n  (fn [& args]\\r\\n    (* 2 (apply f args))))\\r\\n(def double-+ (doubler +))\\r\\n(double-+ 1 2 3)\\r\\n\\r\\n; Define some logger that redirects standard output\\r\\n(defn print-logger\\r\\n  [writer]\\r\\n  \#(binding [*out* writer]\\r\\n     (println %)))\\r\\n\\r\\n; Define logger to standard output and use it\\r\\n(def *out*-logger (print-logger *out*))\\r\\n(*out*-logger \\"hello\\")\\r\\n\\r\\n; Define logger to in-memory buffer\\r\\n(def writer (java.io.StringWriter.))\\r\\n(def retained-logger (print-logger writer))\\r\\n(retained-logger \\"hello\\")\\r\\n(str writer)\\r\\n\\r\\n(require `clojure.java.io)\\r\\n(defn file-logger\\r\\n  [file]\\r\\n  \#(with-open [f (clojure.java.io/writer file \:append true)]\\r\\n     ((print-logger f) %)))\\r\\n(def log->file (file-logger \\"messages.log\\"))" "(log->file \\"hello\\")" "more messages.log" "% more messages.log" "(ns chapter-two.core)\\r\\n\\r\\n; evalutes to true every time\\r\\n(\= 5 5)\\r\\n(\= 5 (+ 2 3))\\r\\n(\= \\"boot\\" (str \\"bo\\" \\"ot\\"))\\r\\n(\= nil nil)\\r\\n(let [a 5]\\r\\n  (- 2 a)\\r\\n  (\= a 5))\\r\\n\\r\\n; demonstrate immutability\\r\\n(def h {[1 2] 3})\\r\\n(h [1 2])\\r\\n(conj (first (keys h)) 3)\\r\\n(h [1 2])\\r\\nh\\r\\n\\r\\n; call a function twice\\r\\n(defn call-twice [f x]\\r\\n (f x)\\r\\n (f x))\\r\\n(call-twice println 123)\\r\\n\\r\\n; call functions as first class objects\\r\\n(max 5 6)\\r\\n(require 'clojure.string)\\r\\n(clojure.string/lower-case \\"Clojure\\")\\r\\n; use map function\\r\\n(map clojure.string/lower-case [\\"Java\\" \\"Imperative\\" \\"Weeping\\" \\"Clojure\\" \\"Learning\\" \\"Peace\\"])\\r\\n(map * [1 2 3 4 5] [5 6 7 8 9])\\r\\n\\r\\n; use reduce function\\r\\n(reduce max [0 -3 10 48])\\r\\n(reduce + 50 [1 2 3 4])\\r\\n(reduce\\r\\n  (fn [m v]\\r\\n    (assoc m v (* v v)))\\r\\n  {}\\r\\n  [1 2 3 4])\\r\\n\\r\\n; Use function application\\r\\n(apply hash-map [\:a 5 \:b 6])\\r\\n(def only-strings (partial filter string?))\\r\\n(only-strings [\\"a\\" 5 \\"b\\" 6])\\r\\n\\r\\n; Define a function literal which forces all arguments to be specified\\r\\n(\#(filter string? %) [\\"a\\" 5 \\"b\\" 6])\\r\\n(\#(filter % [\\"a\\" 5 \\"b\\" 6]) number?)\\r\\n\\r\\n; Use function composition\\r\\n(def negated-sum-str (comp str - +))\\r\\n(negated-sum-str 10 12 3.4)\\r\\n(require '[clojure.string \:as str])\\r\\n(def camel->keyword (comp keyword\\r\\n                          str/join\\r\\n                          (partial interpose \\\\-)\\r\\n                          (partial map str/lower-case)\\r\\n                          \#(str/split % \#\\"(?<\=[a-z])(?\=[A-Z])\\")))\\r\\n(camel->keyword \\"CamelCase\\")\\r\\n(camel->keyword \\"lowerCamelCase\\")\\r\\n\\r\\n; Define some higher order functions\\r\\n(defn adder\\r\\n  [x]\\r\\n  (fn [y] (+ x y)))\\r\\n((adder 5) 18)\\r\\n(defn doubler\\r\\n  [f]\\r\\n  (fn [& args]\\r\\n    (* 2 (apply f args))))\\r\\n(def double-+ (doubler +))\\r\\n(double-+ 1 2 3)\\r\\n\\r\\n; Define some logger that redirects standard output\\r\\n(defn print-logger\\r\\n  [writer]\\r\\n  \#(binding [*out* writer]\\r\\n     (println %)))\\r\\n\\r\\n; Define logger to standard output and use it\\r\\n(def *out*-logger (print-logger *out*))\\r\\n(*out*-logger \\"hello\\")\\r\\n\\r\\n; Define logger to in-memory buffer\\r\\n(def writer (java.io.StringWriter.))\\r\\n(def retained-logger (print-logger writer))\\r\\n(retained-logger \\"hello\\")\\r\\n(str writer)\\r\\n\\r\\n; Define logger to file system\\r\\n(require `clojure.java.io)\\r\\n(defn file-logger\\r\\n  [file]\\r\\n  \#(with-open [f (clojure.java.io/writer file \:append true)]\\r\\n     ((print-logger f) %)))\\r\\n(def log->file (file-logger \\"messages.log\\"))\\r\\n(log->file \\"hello\\")\\r\\n\\r\\n; Define logger to accept a sequence of logging functions\\r\\n(defn multi-logger\\r\\n  [& logger-fns]\\r\\n  \#(doseq [f logger-fns]\\r\\n     (f %)))\\r\\n\\r\\n(def log (multi-logger\\r\\n           (print-logger *out*)\\r\\n           (file-logger \\"messages.log\\")))\\r\\n(log \\"hello again\\")" "\\r\\n(defn timestamped-logger\\r\\n  [logger]\\r\\n  \#(logger (format \\"[%1$tY-%1$tm-%1$te %1$tH\:%1$tM\:%1$tS] %2$s\\" (java.util.Date.) %)))\\r\\n(def log-timestamped (timestamped-logger\\r\\n                       (multi-logger\\r\\n                         (print-logger *out*)\\r\\n                         (file-logger \\"messages.log\\"))))\\r\\n(log-timestamped \\"goodbye, now\\")" "; Use memoization with prime functions\\r\\n(defn prime?\\r\\n  [n]\\r\\n  (cond\\r\\n    (\=\= 1 n) false\\r\\n    (\=\= 2 n) true\\r\\n    (even? n) false\\r\\n    \:else (->> (range 3 (inc (Math/sqrt n)) 2)\\r\\n            (filter \#(zero? (rem n %)))\\r\\n            empty?)))\\r\\n(time (prime? 1125899906842679))" "(time (prime? 1125899906842679))" "(time (prime? 1125899906842679))\\r\\n(let [m-prime? (memoize prime?)]\\r\\n  (time m-prime? 1125899906842679)\\r\\n  (time m-prime? 1125899906842679))" "(time (prime? 1125899906842679))\\r\\n(let [m-prime? (memoize prime?)]\\r\\n  (time (m-prime? 1125899906842679))\\r\\n  (time (m-prime? 1125899906842679)))" "(ns chapter-one-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter_one.core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))\\r\\n\\r\\n; Check that comma evalues to whitespace\\r\\n(deftest comma-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= [1 2 3] [,,,1, 2,,, ,,,, 3,,,,,,,,,,,,,,]))))" "(ns chapter-one-test\\r\\n  (\:require [clojure.test \:refer \:all]\\r\\n            [chapter-one-core \:refer \:all]))\\r\\n\\r\\n; Check that the average of [60 80 100 400] is 160\\r\\n(deftest average-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (average [60 80 100 400]) 160))))\\r\\n\\r\\n; Check that read-string returns a literal\\r\\n(deftest read-string-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (read-string \\"42\\") 42))))\\r\\n\\r\\n; Check that pr-str returns a string\\r\\n(deftest pr-str-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (pr-str [1 2 3]) \\"[1 2 3]\\"))))\\r\\n\\r\\n; Check that a keyword is properly declared\\r\\n(deftest keyword-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:name person) \\"Jacob Malter\\"))))\\r\\n\\r\\n; Check that there is naming collision\\r\\n(deftest namespace-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\"))))\\r\\n\\r\\n; Check that comma evalues to whitespace\\r\\n(deftest comma-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= [1 2 3] [,,,1, 2,,, ,,,, 3,,,,,,,,,,,,,,]))))" "(ns chapter-one-core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n(\= (average [60 80 100 400]) 160)\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)\\r\\n(re-seq regex \\"1-3\\")\\r\\n\\r\\n\\r\\n; Use the reader macro\\r\\n(read-string \\"(+ 1 2 \#_(* 2 2) 8)\\")\\r\\n\\r\\n; Use comment\\r\\n(comment (println \\"hello\\"))\\r\\n\\r\\n; Demonstrate the commas evaluate to whitespace\\r\\n(\= [1 2 3] [1, 2, 3])\\r\\n\\r\\n; Show off literal data structure\\r\\n'(a b \:name 12.5) ;; list\\r\\n['a 'b \:name 12.5] ;; vector\\r\\n{\:name \\"Jacob\\" \:age 20} ;; map\\r\\n\#{1 2 3} ;; set\\r\\n\\r\\n; define a variable\\r\\n(def x 1)\\r\\nx ;\= 1\\r\\n\\r\\n; Demonstrate what eval does\\r\\n(eval \:foo) ;\= \:foo\\r\\n(eval [1 2 3]) ;\= [1 2 3]\\r\\n(eval \\"text\\") ;\= \\"text\\"" "(\= (average [60 80 100 400]) 160)" "(ns chapter-one-core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n(\= (average [60 80 100 400]) 160)\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n(\= (read-string \\"42\\") 42)\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n(\= (pr-str [1 2 3]) \\"[1 2 3]\\")\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)\\r\\n(re-seq regex \\"1-3\\")\\r\\n\\r\\n\\r\\n; Use the reader macro\\r\\n(read-string \\"(+ 1 2 \#_(* 2 2) 8)\\")\\r\\n\\r\\n; Use comment\\r\\n(comment (println \\"hello\\"))\\r\\n\\r\\n; Demonstrate the commas evaluate to whitespace\\r\\n(\= [1 2 3] [1, 2, 3])\\r\\n\\r\\n; Show off literal data structure\\r\\n'(a b \:name 12.5) ;; list\\r\\n['a 'b \:name 12.5] ;; vector\\r\\n{\:name \\"Jacob\\" \:age 20} ;; map\\r\\n\#{1 2 3} ;; set\\r\\n\\r\\n; define a variable\\r\\n(def x 1)\\r\\nx ;\= 1\\r\\n\\r\\n; Demonstrate what eval does\\r\\n(eval \:foo) ;\= \:foo\\r\\n(eval [1 2 3]) ;\= [1 2 3]\\r\\n(eval \\"text\\") ;\= \\"text\\"" "(ns chapter-one-core)\\r\\n\\r\\n; Takes the average of some numbers\\r\\n(defn average\\r\\n  [numbers]\\r\\n  (/ (apply + numbers) (count numbers)))\\r\\n(\= (average [60 80 100 400]) 160)\\r\\n\\r\\n; Read a string and return a literal\\r\\n(read-string \\"42\\")\\r\\n(\= (read-string \\"42\\") 42)\\r\\n\\r\\n; Read a string a return a string literal\\r\\n(pr-str [1 2 3])\\r\\n(\= (pr-str [1 2 3]) \\"[1 2 3]\\")\\r\\n; Declare a string literal\\r\\n\\"hello world\!\\"\\r\\n\\r\\n; Declare a multiline string literal\\r\\n\\"multiline stings\\r\\nare easy to declare\\"\\r\\n\\r\\n; Declare some character literal\\r\\n(class \\\\c) ;\= java.lang.Character\\r\\n\\\\u00ff ;\= \\\\\u00FF\\r\\n\\\\o41 ;\= \\\\\!\\r\\n\\r\\n; Declare a keyword which evaluates to itself\\r\\n(def person {\:name \\"Jacob Malter\\"\\r\\n             \:city \\"Raleigh, NC\\"})\\r\\n(\= (\:name person) \\"Jacob Malter\\")\\r\\n\\r\\n; Declare two keywords with the same name but in different namespaces\\r\\n(def calzones {\:name \\"DP Dough\\"\\r\\n               \:location \\"Raleigh, NC\\"\\r\\n               \:\:location \\"35.779385, -78.675592\\"}) ; every tuesday\\r\\n(\= (\:chapter_one.core/location calzones) \\"35.779385, -78.675592\\")\\r\\n\\r\\n; Declare a regex\\r\\n(def regex \#\\"(\\\\d+)-(\\\\d+)\\")\\r\\n(class regex)\\r\\n(re-seq regex \\"1-3\\")\\r\\n\\r\\n\\r\\n; Use the reader macro\\r\\n(read-string \\"(+ 1 2 \#_(* 2 2) 8)\\")\\r\\n\\r\\n; Use comment\\r\\n(comment (println \\"hello\\"))\\r\\n\\r\\n; Demonstrate the commas evaluate to whitespace\\r\\n(\= [1 2 3] [1, 2, 3])\\r\\n(\= [1 2 3] [,,,1, 2,,, ,,,, 3,,,,,,,,,,,,,,])\\r\\n\\r\\n; Show off literal data structure\\r\\n'(a b \:name 12.5) ;; list\\r\\n['a 'b \:name 12.5] ;; vector\\r\\n{\:name \\"Jacob\\" \:age 20} ;; map\\r\\n\#{1 2 3} ;; set\\r\\n\\r\\n; define a variable\\r\\n(def x 1)\\r\\nx ;\= 1\\r\\n\\r\\n; Demonstrate what eval does\\r\\n(eval \:foo) ;\= \:foo\\r\\n(eval [1 2 3]) ;\= [1 2 3]\\r\\n(eval \\"text\\") ;\= \\"text\\"" "; operate on a vector\\r\\n(def v [1 2 3])\\r\\n(conj v 4)\\r\\n(conj v 4 5)\\r\\n(seq v)" "(def m {\:a 5 \:b 6})\\r\\n(conj m [\:c 7])\\r\\n(seq m)" "(def s \#{1 2 3})\\r\\n(conj s 10)\\r\\n(conj s 3 4)\\r\\n(seq s)" "(def l `(1 2 3))\\r\\n(conj l 0)\\r\\n(conj l 0 -1)\\r\\n(seq l) ; l is not modified by conj" "(into v [4 5])" "(into v [4 5])\\r\\n(into m [[\:c 7] [\:d 8]])\\r\\n(into \#{1 2} [2 3 4 5 3 3 2])\\r\\n(into [1] {\:a 1 \:b 2})" "(conj `(1 2 3) 4)\\r\\n(into `(1 2 3) [\:a \:b \:c])" "; conj guarantees membership into a collection\\r\\n(conj `(1 2 3) 4)\\r\\n(into `(1 2 3) [\:a \:b \:c])\\r\\n\\r\\n; empty creates an empty version of its parameter data structure\\r\\n(defn swap-pairs\\r\\n  [sequential]\\r\\n  (into (empty sequential)\\r\\n        (interleave\\r\\n          (take-nth 2 (drop 1 sequential))\\r\\n          (take-nth 2 sequential))))\\r\\n(swap-pairs (apply list (range 10)))\\r\\n(swap-pairs (apply vector (range 10)))" "(defn map-map\\r\\n  [f m]\\r\\n  (into (empty m)\\r\\n        (for [[k v] m]\\r\\n          [k (f v)])))\\r\\n(map-map inc (hash-map \:z 5 \:c 6 \:a 0))\\r\\n(map-map inc (sorted-map \:z 5 \:c 6 \:a 0))" "(count [1 2 3])\\r\\n(count {\:a 1 \:b 2 \:c 3})\\r\\n(count \#{1 2 3})\\r\\n(count `(1 2 3))" "(\= [1 2 3] [1,,,,,,,,,,,,,,2,,,,,,,,,,,,,,,3])" "(\= [1 2 3] `(1 2 3))" "(\= [1 2 3] \#{1 2 3})" "(\= {\:a 1 \:b 2 \:c 3} {\:b 2 \:c 3 \:a 1})" "(\= [1 2 3] [1,,,,,,,,,,,,,,2,,,,,,,,,,,,,,,3])\\r\\n(\= {\:a 1 \:b 2 \:c 3} {\:b 2 \:c 3 \:a 1})\\r\\n(\= \#{1 2 3} \#{2 3 1})\\r\\n(\= [1 2 3] `(1 2 3))" "(\= [1 2 3] `(1 2 3))\\r\\n(\= {\:a 1 \:b 2 \:c 3} {\:b 2 \:c 3 \:a 1})\\r\\n(\= \#{1 2 3} \#{2 3 1})\\r\\n(\= `(1 2 3) [1 2 3])"]
eclipse.preferences.version=1
